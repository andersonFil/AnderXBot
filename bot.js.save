import makeWASocket, { useMultiFileAuthState } from "@whiskeysockets/baileys";
import ytSearch from "yt-search";
import fs from "fs";
import { spawn } from "child_process";
import fetch from "node-fetch";

const ADMIN = "584247057716"; // tu n√∫mero admin
let contadorComandos = 0;
const inicioBot = Date.now();

// ‚úÖ Reconocimiento de admin robusto
function esAdmin(sender) {
  if (!sender) return false;
  const limpio = sender.replace(/\D/g, ""); // elimina todo lo que no sea n√∫mero
  return limpio === ADMIN;
}

// Ejecutar yt-dlp
function runYtDlp(args, onStdout) {
  return new Promise((resolve, reject) => {
    const proc = spawn("yt-dlp", args);
    proc.stdout.on("data", (d) => onStdout?.(d.toString()));
    proc.stderr.on("data", (d) => onStdout?.(d.toString()));
    proc.on("error", reject);
    proc.on("close", (code) => (code === 0 ? resolve(true) : reject(new Error("yt-dlp error"))));
  });
}

// Buscar primer resultado en YouTube
async function searchFirst(query) {
  const res = await ytSearch(query);
  if (res && res.videos && res.videos.length > 0) return res.videos[0];
  return null;
}

async function main() {
  const { state, saveCreds } = await useMultiFileAuthState("auth");
  const sock = makeWASocket({ auth: state });
  sock.ev.on("creds.update", saveCreds);

  sock.ev.on("messages.upsert", async ({ messages }) => {
    try {
      const msg = messages[0];
      if (!msg?.message) return;

      const sender = msg.key.participant || msg.key.remoteJid;
      const chatId = msg.key.remoteJid;
      const text =
        msg.message.conversation ||
        msg.message.extendedTextMessage?.text ||
        msg.message?.imageMessage?.caption ||
        msg.message?.videoMessage?.caption ||
        "";
      const body = text.trim();
      contadorComandos++;

      // üìå Help
      if (body === "!help") {
        let helpText = "üìå *Lista de comandos disponibles:*\n\n";
        helpText += "‚Ä¢ *!mp4 <nombre>*\n  Descarga el primer video relacionado y lo env√≠a como video ligero.\n\n";
        helpText += "‚Ä¢ *!mp3 <nombre>*\n  Descarga el audio del primer video relacionado y lo env√≠a como archivo MP3.\n\n";
        helpText += "‚Ä¢ *!pi <nombre>* o *!p <nombre>*\n  Busca una imagen relacionada y la env√≠a como foto.\n\n";
        helpText += "‚Ä¢ *!estado*\n  Muestra el estado actual del bot.\n\n";
        helpText += "‚Ä¢ *!limpiar*\n  Elimina archivos temporales del bot.\n\n";
        helpText += "üîû *Comandos adultos:*\n";
        helpText += "‚Ä¢ *!nn <nombre>*\n  (Desactivado por defecto. Solo admin puede activarlo.)\n\n";
        if (esAdmin(sender)) {
          helpText += "‚≠ê *Prime Commands (solo admin):*\n";
          helpText += "‚Ä¢ *!mp4 <nombre> <documento>*\n  Descarga el video en calidad alta y lo env√≠a como documento.\n\n";
          helpText += "‚Ä¢ *!nn activar* / *!nn desactivar*\n  Activa o desactiva el comando adultos.\n\n";
          helpText += "‚Ä¢ *!limpiar*\n  Limpia archivos temporales del bot.\n\n";
        }
        await sock.sendMessage(chatId, { text: helpText, quoted: msg });
        return;
      }

      // üìä Estado
      if (body === "!estado") {
        const uptimeMs = Date.now() - inicioBot;
        const minutos = Math.floor(uptimeMs / 60000);
        const memoria = process.memoryUsage().rss / 1024 / 1024;
        await sock.sendMessage(chatId, {
          text: `üìä Estado del bot:\n\n‚è±Ô∏è Tiempo activo: ${minutos} min\nüß† Memoria usada: ${memoria.toFixed(1)} MB\n‚öôÔ∏è Comandos ejecutados: ${contadorComandos}`,
          quoted: msg
        });
        return;
      }

      // üßπ Limpiar
      if (body === "!limpiar") {
        //if (!esAdmin(sender)) {
	ifff
          await sock.sendMessage(chatId, { text: "üîí Solo el admin puede ejecutar !limpiar.", quoted: msg });
          return;
        }
        const archivos = ["./video.mp4","./video.webm","./video.mkv","./audio.mp3"];
        archivos.forEach(f => { try { if (fs.existsSync(f)) fs.unlinkSync(f); } catch(_){} });
        await sock.sendMessage(chatId, { text: "üßπ Archivos temporales eliminados correctamente.", quoted: msg });
        return;
      }

      // üñºÔ∏è Imagen
      if (body.startsWith("!pi ") || body.startsWith("!p ")) {
        const query = body.replace(/^!(pi|p) /, "").trim();
        if (!query) {
          await sock.sendMessage(chatId, { text: "‚ùå Falta el nombre. Usa: !pi <nombre>", quoted: msg });
          return;
        }

        try {
          const res = await fetch(`https://source.unsplash.com/600x400/?${encodeURIComponent(query)}`);
          if (!res.ok) throw new Error("No se pudo obtener la imagen");
          const buffer = Buffer.from(await res.arrayBuffer());
          if (!buffer || buffer.length < 1000) throw new Error("Imagen inv√°lida");

          await sock.sendMessage(chatId, {
            image: buffer,
            caption: `üñºÔ∏è Imagen relacionada con: ${query}`,
            quoted: msg
          });
        } catch (e) {
          await sock.sendMessage(chatId, { text: "‚ùå No pude obtener la imagen.", quoted: msg });
        }
        return;
      }
	// üé¨ Video
      if (body.startsWith("!mp4 ")) {
        const parts = body.split(" ").filter(Boolean);
        const modoDocumento = parts.includes("<documento>") && esAdmin(sender);
        const query = parts.slice(1).filter(p => p !== "<documento>").join(" ").trim();
        if (!query) {
          await sock.sendMessage(chatId, { text: "‚ùå Falta el nombre. Usa: !mp4 <nombre>", quoted: msg });
          return;
        }

        const found = await searchFirst(query);
        if (!found) {
          await sock.sendMessage(chatId, { text: "‚ùå No encontr√© resultados para ese nombre.", quoted: msg });
          return;
        }

        const format = modoDocumento ? "best" : "mp4"; // ‚úÖ correcci√≥n
        const outPath = "./video.%(ext)s";
        let realFile = "";

        await sock.sendMessage(chatId, { text: `‚è¨ Descargando: ${found.title}`, quoted: msg });

        try {
          await runYtDlp([
            "-f", format,
            "-o", outPath,
            found.url
          ], log => {
            const m = log.match(/Destination:\s(.+\.(mp4|mkv|webm))/i);
            if (m && m[1]) realFile = m[1];
          });

          if (!realFile) {
            if (fs.existsSync("./video.mp4")) realFile = "./video.mp4";
            else if (fs.existsSync("./video.webm")) realFile = "./video.webm";
            else if (fs.existsSync("./video.mkv")) realFile = "./video.mkv";
          }
          if (!realFile || !fs.existsSync(realFile)) {
            await sock.sendMessage(chatId, { text: "‚ùå No pude ubicar el archivo descargado.", quoted: msg });
            return;
          }

          const buffer = fs.readFileSync(realFile);
          if (modoDocumento) {
            await sock.sendMessage(chatId, {
              document: buffer,
              mimetype: "video/mp4",
              fileName: `${found.title}.mp4`,
              caption: `üé¨ ${found.title}\nüîó ${found.url}`,
              quoted: msg
            });
          } else {
            await sock.sendMessage(chatId, {
              video: buffer,
              caption: `üé¨ ${found.title}\nüîó ${found.url}`,
              quoted: msg
            });
          }
        } catch (e) {
          await sock.sendMessage(chatId, { text: "‚ùå Error al descargar el video.", quoted: msg });
        } finally {
          try { if (realFile && fs.existsSync(realFile)) fs.unlinkSync(realFile); } catch (_) {}
        }
        return;
      }

      // üéß Audio
      if (body.startsWith("!mp3 ")) {
        const query = body.replace("!mp3 ", "").trim();
        if (!query) {
          await sock.sendMessage(chatId, { text: "‚ùå Falta el nombre. Usa: !mp3 <nombre>", quoted: msg });
          return;
        }

        const found = await searchFirst(query);
        if (!found) {
          await sock.sendMessage(chatId, { text: "‚ùå No encontr√© resultados para ese nombre.", quoted: msg });
          return;
        }

        const outPath = "./audio.%(ext)s";
        let realFile = "";

        await sock.sendMessage(chatId, { text: `‚è¨ Descargando audio: ${found.title}`, quoted: msg });

        try {
          await runYtDlp([
            "-x", "--audio-format", "mp3",
            "-o", outPath,
            found.url
          ], log => {
            const m = log.match(/Destination:\s(.+\.mp3)/i);
            if (m && m[1]) realFile = m[1];
          });

          if (!realFile) {
            if (fs.existsSync("./audio.mp3")) realFile = "./audio.mp3";
          }
          if (!realFile || !fs.existsSync(realFile)) {
            await sock.sendMessage(chatId, { text: "‚ùå No pude ubicar el MP3 descargado.", quoted: msg });
            return;
          }

          const buffer = fs.readFileSync(realFile);
          await sock.sendMessage(chatId, {
            document: buffer,
            mimetype: "audio/mpeg",
            fileName: `${found.title}.mp3`,
            caption: `üéß ${found.title}\nüîó ${found.url}`,
            quoted: msg
          });
        } catch (e) {
          await sock.sendMessage(chatId, { text: "‚ùå Error al convertir a MP3.", quoted: msg });
        } finally {
          try { if (realFile && fs.existsSync(realFile)) fs.unlinkSync(realFile); } catch (_) {}
        }
        return;
      }

      // üîû Adultos
      if (body.startsWith("!nn ")) {
        await sock.sendMessage(chatId, { text: "üîí El comando nn est√° desactivado por seguridad.", quoted: msg });
        return;
      }
      if (body === "!nn activar" && esAdmin(sender)) {
        await sock.sendMessage(chatId, { text: "‚úÖ Comando nn activado (modo seguro, sin descargas expl√≠citas).", quoted: msg });
        return;
      }
      if (body === "!nn desactivar" && esAdmin(sender)) {
        await sock.sendMessage(chatId, { text: "‚úÖ Comando nn desactivado.", quoted: msg });
        return;
      }

    } catch (e) {
      console.error("‚ùå Error procesando mensaje:", e);
    }
  });
}

main();
